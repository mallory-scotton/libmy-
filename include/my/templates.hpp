/*
** EPITECH PROJECT, 2024
** libmy++ - templates
** File description:
** templates
*/

#ifndef TEMPLATES_HPP_
    #define TEMPLATES_HPP_

///////////////////////////////////////////////////////////////////////////////
/// \brief Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <my/types.hpp>
#include <type_traits>
#include <cstring>

///////////////////////////////////////////////////////////////////////////////
/// \brief Namespace my::templates
///////////////////////////////////////////////////////////////////////////////
namespace my::templates
{

///////////////////////////////////////////////////////////////////////////////
/// \brief Utility template for `true`
///////////////////////////////////////////////////////////////////////////////
struct TrueType { public: static constexpr bool value = true; };

///////////////////////////////////////////////////////////////////////////////
/// \brief Utility template for `false`
///////////////////////////////////////////////////////////////////////////////
struct FalseType { public: static constexpr bool value = false; };

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T>
struct TypeCompatibleBytes
{
public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///////////////////////////////////////////////////////////////////////////
    alignas(T) uint8 padding[sizeof(T)];

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///////////////////////////////////////////////////////////////////////////
    T* getTypedPtr(void) { return ((T*)this); }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///////////////////////////////////////////////////////////////////////////
    const T* getTypedPtr(void) const { return ((const T*)this); }
};

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam To
/// \tparam From
///
/// \param from
///
/// \return
///////////////////////////////////////////////////////////////////////////////
template <
    typename To,
    typename From,
    std::enable_if_t<
        sizeof(To) == sizeof(From) &&
        std::is_trivially_copyable_v<To> &&
        std::is_trivially_copyable_v<From>
    >* = nullptr
>
inline To BitCast(const From& from)
{
    TypeCompatibleBytes<From> result;
    std::memcpy(&result, &from, sizeof(To));
    return (*result.getTypedPtr());
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> struct RemoveConst { public: using type = T; };

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> using RemoveConstT = typename RemoveConst<T>::type;

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> struct RemoveVolatile { public: using type = T; };

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> using RemoveVolatileT = typename RemoveVolatile<T>::type;

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> struct RemoveCV
{
public:
    using type = typename RemoveConst<typename RemoveVolatile<T>::type>::type;
};

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///////////////////////////////////////////////////////////////////////////////
template <typename T> using RemoveCVT = typename RemoveCV<T>::type;

} // !my::templates

#endif /* !TEMPLATES_HPP_ */
